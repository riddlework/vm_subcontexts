\chapter*{CONCLUSION}
\thispagestyle{fancy}
\addcontentsline{toc}{chapter}{CONCLUSION}
Shared libraries, while ubiquitous, inherently adopt the protection boundaries of the processes into which they are linked. This presents a longstanding architectural limitation: once a trusted library is dynamically linked into an untrusted process, it itself becomes untrusted, and is thus exposed to potential misuse or corruption. This problem is particularly acute in low-level languages like C, where memory safety cannot be assumed. Our work addresses this issue by introducing subcontexts of virtual memory, a novel abstraction that seeks to preserve the modularity of shared libraries while restoring their original protection boundary.

In this thesis, we have designed, implemented, and evaluated a prototype system that demonstrates the conceptual and practical feasibility of virtual memory subcontexts. Essentially, a subcontext is a frozen snapshot of a process--a serialized and invokable swath of (possibly discontiguous) memory. Subcontexts can be mapped into a client process's virtual address space and safely invoked, without requiring dynamic linking or kernel-level privilege transitions. The design relies on a tripartite architecture consisting of a server-side library (to create subcontexts), a client-side library (to map and invoke them), and a matchmaker (part of the client-side library, responsible for managing execution-time memory protections). Together, these components enable a new memory-sharing paradigm that is safe, lightweight, and modular.

We demonstrated that it is indeed possible to embed trusted logic inside an untrusted process without relinquishing protection guarantees by compromising memory isolation. However, our work also makes clear the limitations and open challenges that remain. The current prototype is single-threaded, limited in its image file format, and still relies on shared libraries for implementation. Additionally, the client-server interface is coarse, and our design assumes generous availability of unused virtual memory in modern processes, an assumption that may not hold in more constrained environments. Perhaps most critically, development of our prototype revealed a problems with the dynamic linker in the presence of aggressive memory remapping, which poses challenges for long-term subcontext stability and integration into real-world applications.

Despite these limitations, we believe our results are both encouraging and instructive. They offer a new way to think about modularity and trust in systems design that prioritizes memory safety and control over traditional linking convenience. Subcontexts may not replace shared libraries outright, but they offer a complementary model that could be especially valuable in high-assurance systems, sandboxing, or modular runtime environments.

This project was born from a vague, almost architectural impulseâ€”an intuition about the nature of modularity, trust, and memory. Through iterative implementation and experimentation, we shaped that intuition into a functioning system. In doing so, we not only built a working prototype, but also clarified the conceptual space that subcontexts inhabit: somewhere between a library and a process.

Future work will explore integration with the kernel, support for multi-threading, more sophisticated file formats, and perhaps even hardware-enforced variants of subcontexts. We envision a world in which processes can safely compose functionality at runtime by embedding trusted modules that retain their own protection boundaries, even when embedded in the memory of other untrusted modules.

Subcontexts challenge the traditional boundaries of trust and memory in operating systems. They do not replace our existing abstractions. They augment them by offering a new lens through which we might rethink the architecture of shared functionality.